{"ast":null,"code":"\"use strict\";\n\nvar url = require('url'),\n    auth_hdr = require('./auth_header'); // Note: express http converts all headers\n// to lower case.\n\n\nvar AUTH_HEADER = \"authorization\",\n    LEGACY_AUTH_SCHEME = \"JWT\",\n    BEARER_AUTH_SCHEME = 'bearer';\nvar extractors = {};\n\nextractors.fromHeader = function (header_name) {\n  return function (request) {\n    var token = null;\n\n    if (request.headers[header_name]) {\n      token = request.headers[header_name];\n    }\n\n    return token;\n  };\n};\n\nextractors.fromBodyField = function (field_name) {\n  return function (request) {\n    var token = null;\n\n    if (request.body && Object.prototype.hasOwnProperty.call(request.body, field_name)) {\n      token = request.body[field_name];\n    }\n\n    return token;\n  };\n};\n\nextractors.fromUrlQueryParameter = function (param_name) {\n  return function (request) {\n    var token = null,\n        parsed_url = url.parse(request.url, true);\n\n    if (parsed_url.query && Object.prototype.hasOwnProperty.call(parsed_url.query, param_name)) {\n      token = parsed_url.query[param_name];\n    }\n\n    return token;\n  };\n};\n\nextractors.fromAuthHeaderWithScheme = function (auth_scheme) {\n  var auth_scheme_lower = auth_scheme.toLowerCase();\n  return function (request) {\n    var token = null;\n\n    if (request.headers[AUTH_HEADER]) {\n      var auth_params = auth_hdr.parse(request.headers[AUTH_HEADER]);\n\n      if (auth_params && auth_scheme_lower === auth_params.scheme.toLowerCase()) {\n        token = auth_params.value;\n      }\n    }\n\n    return token;\n  };\n};\n\nextractors.fromAuthHeaderAsBearerToken = function () {\n  return extractors.fromAuthHeaderWithScheme(BEARER_AUTH_SCHEME);\n};\n\nextractors.fromExtractors = function (extractors) {\n  if (!Array.isArray(extractors)) {\n    throw new TypeError('extractors.fromExtractors expects an array');\n  }\n\n  return function (request) {\n    var token = null;\n    var index = 0;\n\n    while (!token && index < extractors.length) {\n      token = extractors[index].call(this, request);\n      index++;\n    }\n\n    return token;\n  };\n};\n/**\n * This extractor mimics the behavior of the v1.*.* extraction logic.\n *\n * This extractor exists only to provide an easy transition from the v1.*.* API to the v2.0.0\n * API.\n *\n * This extractor first checks the auth header, if it doesn't find a token there then it checks the \n * specified body field and finally the url query parameters.\n * \n * @param options\n *          authScheme: Expected scheme when JWT can be found in HTTP Authorize header. Default is JWT. \n *          tokenBodyField: Field in request body containing token. Default is auth_token.\n *          tokenQueryParameterName: Query parameter name containing the token. Default is auth_token.\n */\n\n\nextractors.versionOneCompatibility = function (options) {\n  var authScheme = options.authScheme || LEGACY_AUTH_SCHEME,\n      bodyField = options.tokenBodyField || 'auth_token',\n      queryParam = options.tokenQueryParameterName || 'auth_token';\n  return function (request) {\n    var authHeaderExtractor = extractors.fromAuthHeaderWithScheme(authScheme);\n    var token = authHeaderExtractor(request);\n\n    if (!token) {\n      var bodyExtractor = extractors.fromBodyField(bodyField);\n      token = bodyExtractor(request);\n    }\n\n    if (!token) {\n      var queryExtractor = extractors.fromUrlQueryParameter(queryParam);\n      token = queryExtractor(request);\n    }\n\n    return token;\n  };\n};\n/**\n * Export the Jwt extraction functions\n */\n\n\nmodule.exports = extractors;","map":{"version":3,"sources":["C:/Users/Sohrab/Desktop/Evaly/E-Frontend/node_modules/passport-jwt/lib/extract_jwt.js"],"names":["url","require","auth_hdr","AUTH_HEADER","LEGACY_AUTH_SCHEME","BEARER_AUTH_SCHEME","extractors","fromHeader","header_name","request","token","headers","fromBodyField","field_name","body","Object","prototype","hasOwnProperty","call","fromUrlQueryParameter","param_name","parsed_url","parse","query","fromAuthHeaderWithScheme","auth_scheme","auth_scheme_lower","toLowerCase","auth_params","scheme","value","fromAuthHeaderAsBearerToken","fromExtractors","Array","isArray","TypeError","index","length","versionOneCompatibility","options","authScheme","bodyField","tokenBodyField","queryParam","tokenQueryParameterName","authHeaderExtractor","bodyExtractor","queryExtractor","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar url = require('url'),\n    auth_hdr = require('./auth_header');\n\n// Note: express http converts all headers\n// to lower case.\nvar AUTH_HEADER = \"authorization\",\n    LEGACY_AUTH_SCHEME = \"JWT\", \n    BEARER_AUTH_SCHEME = 'bearer';\n\n\nvar extractors = {};\n\n\nextractors.fromHeader = function (header_name) {\n    return function (request) {\n        var token = null;\n        if (request.headers[header_name]) {\n            token = request.headers[header_name];\n        }\n        return token;\n    };\n};\n\n\n\nextractors.fromBodyField = function (field_name) {\n    return function (request) {\n        var token = null;\n        if (request.body && Object.prototype.hasOwnProperty.call(request.body, field_name)) {\n            token = request.body[field_name];\n        }\n        return token;\n    };\n};\n\n\n\nextractors.fromUrlQueryParameter = function (param_name) {\n    return function (request) {\n        var token = null,\n            parsed_url = url.parse(request.url, true);\n        if (parsed_url.query && Object.prototype.hasOwnProperty.call(parsed_url.query, param_name)) {\n            token = parsed_url.query[param_name];\n        }\n        return token;\n    };\n};\n\n\n\nextractors.fromAuthHeaderWithScheme = function (auth_scheme) {\n    var auth_scheme_lower = auth_scheme.toLowerCase();\n    return function (request) {\n\n        var token = null;\n        if (request.headers[AUTH_HEADER]) {\n            var auth_params = auth_hdr.parse(request.headers[AUTH_HEADER]);\n            if (auth_params && auth_scheme_lower === auth_params.scheme.toLowerCase()) {\n                token = auth_params.value;\n            }\n        }\n        return token;\n    };\n};\n\n\n\nextractors.fromAuthHeaderAsBearerToken = function () {\n    return extractors.fromAuthHeaderWithScheme(BEARER_AUTH_SCHEME);\n};\n\n\nextractors.fromExtractors = function(extractors) {\n    if (!Array.isArray(extractors)) {\n        throw new TypeError('extractors.fromExtractors expects an array')\n    }\n    \n    return function (request) {\n        var token = null;\n        var index = 0;\n        while(!token && index < extractors.length) {\n            token = extractors[index].call(this, request);\n            index ++;\n        }\n        return token;\n    }\n};\n\n\n/**\n * This extractor mimics the behavior of the v1.*.* extraction logic.\n *\n * This extractor exists only to provide an easy transition from the v1.*.* API to the v2.0.0\n * API.\n *\n * This extractor first checks the auth header, if it doesn't find a token there then it checks the \n * specified body field and finally the url query parameters.\n * \n * @param options\n *          authScheme: Expected scheme when JWT can be found in HTTP Authorize header. Default is JWT. \n *          tokenBodyField: Field in request body containing token. Default is auth_token.\n *          tokenQueryParameterName: Query parameter name containing the token. Default is auth_token.\n */\nextractors.versionOneCompatibility = function (options) {\n    var authScheme = options.authScheme || LEGACY_AUTH_SCHEME,\n        bodyField = options.tokenBodyField || 'auth_token',\n        queryParam = options.tokenQueryParameterName || 'auth_token';\n\n    return function (request) {\n        var authHeaderExtractor = extractors.fromAuthHeaderWithScheme(authScheme);\n        var token =  authHeaderExtractor(request);\n        \n        if (!token) {\n            var bodyExtractor = extractors.fromBodyField(bodyField);\n            token = bodyExtractor(request);\n        }\n\n        if (!token) {\n            var queryExtractor = extractors.fromUrlQueryParameter(queryParam);\n            token = queryExtractor(request);\n        }\n\n        return token;\n    };\n}\n\n\n\n/**\n * Export the Jwt extraction functions\n */\nmodule.exports = extractors;\n"]},"metadata":{},"sourceType":"script"}