{"ast":null,"code":"var passport = require('passport-strategy'),\n    auth_hdr = require('./auth_header'),\n    util = require('util'),\n    url = require('url'),\n    assign = require('./helpers/assign.js');\n/**\n * Strategy constructor\n *\n * @param options\n *          secretOrKey: String or buffer containing the secret or PEM-encoded public key. Required unless secretOrKeyProvider is provided.\n *          secretOrKeyProvider: callback in the format secretOrKeyProvider(request, rawJwtToken, done)`,\n *                               which should call done with a secret or PEM-encoded public key\n *                               (asymmetric) for the given undecoded jwt token string and  request\n *                               combination. done has the signature function done(err, secret).\n *                               REQUIRED unless `secretOrKey` is provided.\n *          jwtFromRequest: (REQUIRED) Function that accepts a reqeust as the only parameter and returns the either JWT as a string or null\n *          issuer: If defined issuer will be verified against this value\n *          audience: If defined audience will be verified against this value\n *          algorithms: List of strings with the names of the allowed algorithms. For instance, [\"HS256\", \"HS384\"].\n *          ignoreExpiration: if true do not validate the expiration of the token.\n *          passReqToCallback: If true the, the verify callback will be called with args (request, jwt_payload, done_callback).\n * @param verify - Verify callback with args (jwt_payload, done_callback) if passReqToCallback is false,\n *                 (request, jwt_payload, done_callback) if true.\n */\n\n\nfunction JwtStrategy(options, verify) {\n  passport.Strategy.call(this);\n  this.name = 'jwt';\n  this._secretOrKeyProvider = options.secretOrKeyProvider;\n\n  if (options.secretOrKey) {\n    if (this._secretOrKeyProvider) {\n      throw new TypeError('JwtStrategy has been given both a secretOrKey and a secretOrKeyProvider');\n    }\n\n    this._secretOrKeyProvider = function (request, rawJwtToken, done) {\n      done(null, options.secretOrKey);\n    };\n  }\n\n  if (!this._secretOrKeyProvider) {\n    throw new TypeError('JwtStrategy requires a secret or key');\n  }\n\n  this._verify = verify;\n\n  if (!this._verify) {\n    throw new TypeError('JwtStrategy requires a verify callback');\n  }\n\n  this._jwtFromRequest = options.jwtFromRequest;\n\n  if (!this._jwtFromRequest) {\n    throw new TypeError('JwtStrategy requires a function to retrieve jwt from requests (see option jwtFromRequest)');\n  }\n\n  this._passReqToCallback = options.passReqToCallback;\n  var jsonWebTokenOptions = options.jsonWebTokenOptions || {}; //for backwards compatibility, still allowing you to pass\n  //audience / issuer / algorithms / ignoreExpiration\n  //on the options.\n\n  this._verifOpts = assign({}, jsonWebTokenOptions, {\n    audience: options.audience,\n    issuer: options.issuer,\n    algorithms: options.algorithms,\n    ignoreExpiration: !!options.ignoreExpiration\n  });\n}\n\nutil.inherits(JwtStrategy, passport.Strategy);\n/**\n * Allow for injection of JWT Verifier.\n *\n * This improves testability by allowing tests to cleanly isolate failures in the JWT Verification\n * process from failures in the passport related mechanics of authentication.\n *\n * Note that this should only be replaced in tests.\n */\n\nJwtStrategy.JwtVerifier = require('./verify_jwt');\n/**\n * Authenticate request based on JWT obtained from header or post body\n */\n\nJwtStrategy.prototype.authenticate = function (req, options) {\n  var self = this;\n\n  var token = self._jwtFromRequest(req);\n\n  if (!token) {\n    return self.fail(new Error(\"No auth token\"));\n  }\n\n  this._secretOrKeyProvider(req, token, function (secretOrKeyError, secretOrKey) {\n    if (secretOrKeyError) {\n      self.fail(secretOrKeyError);\n    } else {\n      // Verify the JWT\n      JwtStrategy.JwtVerifier(token, secretOrKey, self._verifOpts, function (jwt_err, payload) {\n        if (jwt_err) {\n          return self.fail(jwt_err);\n        } else {\n          // Pass the parsed token to the user\n          var verified = function (err, user, info) {\n            if (err) {\n              return self.error(err);\n            } else if (!user) {\n              return self.fail(info);\n            } else {\n              return self.success(user, info);\n            }\n          };\n\n          try {\n            if (self._passReqToCallback) {\n              self._verify(req, payload, verified);\n            } else {\n              self._verify(payload, verified);\n            }\n          } catch (ex) {\n            self.error(ex);\n          }\n        }\n      });\n    }\n  });\n};\n/**\n * Export the Jwt Strategy\n */\n\n\nmodule.exports = JwtStrategy;","map":{"version":3,"sources":["C:/Users/Sohrab/Desktop/Evaly/E-Frontend/node_modules/passport-jwt/lib/strategy.js"],"names":["passport","require","auth_hdr","util","url","assign","JwtStrategy","options","verify","Strategy","call","name","_secretOrKeyProvider","secretOrKeyProvider","secretOrKey","TypeError","request","rawJwtToken","done","_verify","_jwtFromRequest","jwtFromRequest","_passReqToCallback","passReqToCallback","jsonWebTokenOptions","_verifOpts","audience","issuer","algorithms","ignoreExpiration","inherits","JwtVerifier","prototype","authenticate","req","self","token","fail","Error","secretOrKeyError","jwt_err","payload","verified","err","user","info","error","success","ex","module","exports"],"mappings":"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","sourcesContent":["var passport = require('passport-strategy')\n    , auth_hdr = require('./auth_header')\n    , util = require('util')\n    , url = require('url')\n    , assign = require('./helpers/assign.js');\n\n\n\n/**\n * Strategy constructor\n *\n * @param options\n *          secretOrKey: String or buffer containing the secret or PEM-encoded public key. Required unless secretOrKeyProvider is provided.\n *          secretOrKeyProvider: callback in the format secretOrKeyProvider(request, rawJwtToken, done)`,\n *                               which should call done with a secret or PEM-encoded public key\n *                               (asymmetric) for the given undecoded jwt token string and  request\n *                               combination. done has the signature function done(err, secret).\n *                               REQUIRED unless `secretOrKey` is provided.\n *          jwtFromRequest: (REQUIRED) Function that accepts a reqeust as the only parameter and returns the either JWT as a string or null\n *          issuer: If defined issuer will be verified against this value\n *          audience: If defined audience will be verified against this value\n *          algorithms: List of strings with the names of the allowed algorithms. For instance, [\"HS256\", \"HS384\"].\n *          ignoreExpiration: if true do not validate the expiration of the token.\n *          passReqToCallback: If true the, the verify callback will be called with args (request, jwt_payload, done_callback).\n * @param verify - Verify callback with args (jwt_payload, done_callback) if passReqToCallback is false,\n *                 (request, jwt_payload, done_callback) if true.\n */\nfunction JwtStrategy(options, verify) {\n\n    passport.Strategy.call(this);\n    this.name = 'jwt';\n\n    this._secretOrKeyProvider = options.secretOrKeyProvider;\n\n    if (options.secretOrKey) {\n        if (this._secretOrKeyProvider) {\n          \tthrow new TypeError('JwtStrategy has been given both a secretOrKey and a secretOrKeyProvider');\n        }\n        this._secretOrKeyProvider = function (request, rawJwtToken, done) {\n            done(null, options.secretOrKey)\n        };\n    }\n\n    if (!this._secretOrKeyProvider) {\n        throw new TypeError('JwtStrategy requires a secret or key');\n    }\n\n    this._verify = verify;\n    if (!this._verify) {\n        throw new TypeError('JwtStrategy requires a verify callback');\n    }\n\n    this._jwtFromRequest = options.jwtFromRequest;\n    if (!this._jwtFromRequest) {\n        throw new TypeError('JwtStrategy requires a function to retrieve jwt from requests (see option jwtFromRequest)');\n    }\n\n    this._passReqToCallback = options.passReqToCallback;\n    var jsonWebTokenOptions = options.jsonWebTokenOptions || {};\n    //for backwards compatibility, still allowing you to pass\n    //audience / issuer / algorithms / ignoreExpiration\n    //on the options.\n    this._verifOpts = assign({}, jsonWebTokenOptions, {\n      audience: options.audience,\n      issuer: options.issuer,\n      algorithms: options.algorithms,\n      ignoreExpiration: !!options.ignoreExpiration\n    });\n\n}\nutil.inherits(JwtStrategy, passport.Strategy);\n\n\n\n/**\n * Allow for injection of JWT Verifier.\n *\n * This improves testability by allowing tests to cleanly isolate failures in the JWT Verification\n * process from failures in the passport related mechanics of authentication.\n *\n * Note that this should only be replaced in tests.\n */\nJwtStrategy.JwtVerifier = require('./verify_jwt');\n\n\n\n/**\n * Authenticate request based on JWT obtained from header or post body\n */\nJwtStrategy.prototype.authenticate = function(req, options) {\n    var self = this;\n\n    var token = self._jwtFromRequest(req);\n\n    if (!token) {\n        return self.fail(new Error(\"No auth token\"));\n    }\n\n    this._secretOrKeyProvider(req, token, function(secretOrKeyError, secretOrKey) {\n        if (secretOrKeyError) {\n            self.fail(secretOrKeyError)\n        } else {\n            // Verify the JWT\n            JwtStrategy.JwtVerifier(token, secretOrKey, self._verifOpts, function(jwt_err, payload) {\n                if (jwt_err) {\n                    return self.fail(jwt_err);\n                } else {\n                    // Pass the parsed token to the user\n                    var verified = function(err, user, info) {\n                        if(err) {\n                            return self.error(err);\n                        } else if (!user) {\n                            return self.fail(info);\n                        } else {\n                            return self.success(user, info);\n                        }\n                    };\n\n                    try {\n                        if (self._passReqToCallback) {\n                            self._verify(req, payload, verified);\n                        } else {\n                            self._verify(payload, verified);\n                        }\n                    } catch(ex) {\n                        self.error(ex);\n                    }\n                }\n            });\n        }\n    });\n};\n\n\n\n/**\n * Export the Jwt Strategy\n */\n module.exports = JwtStrategy;\n"]},"metadata":{},"sourceType":"script"}